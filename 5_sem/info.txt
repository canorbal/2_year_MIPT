
sem 5

Сигналы

- спобос операционной системы доставить процессу/передать небольшое количество информации
посмотреть сигналы:
    man 7 signal
    sigusr1 и sigusr2 - сигналы, которые могут передавать между собой программы

когда запускается процесс создается pidfile, в котором записан его pid

посылать сигналы - функция kill() из man 2 kill

функция signal() - устаревшая, потому что возможны 'race'

      ассемблер
      i++ ~
      mov &i, eax
      inc eax
      mov eax, i

          но signal подойдет для обычной распечатки (например),
пример со списком показывает некорректность


SUGHUP - посылает конфигурацию

у процесса есть маска сигналов, которая определяет сигналы, которые процессу можно доставить
  в данный момент времени
      'когда handler() исполняется, блокируй все остальное'

функция sigaction():
    у программы есть одна маска сигнала (например, все сигналы могут быть доставлены),
      но на момент обработки сигналов маску можно подменить (поставить невозможность доставки сигнала)


функции для модификации маски sigset_t
    int sigemptyset() - все позиции в ноль в маске
    int sigfillset() - все позиции в ноль
    int  addset() - ставит в единичку
    int delset()
    int is


если теперь в исправленную программу послать 2 раза - ОК
                                      послать 3 раза - отработает только 2 раза

        в битовой маске сигналов нет количества сигналов, есть только маска
              сигнала, которая хранит принятые сигналы
              Поэтому если пришло два = сигнала почти одновременно, то может исполниться только один

у сигналов есть свои дефолтные обработчики

сигналы SIGKILL и SIGSTOP не могут быть обработаны

Как писать программы:
    на этапе инициализации программы выставляется блокировка всех сигналов
            с помощью sigprogmask()
                          1) перед инициализацией заблокировать
                          2) после инициализации разблокировать


функция sigsuspend - усыпляет программу до тех пор пока не придет сигнал из маски сигналов программы
    если нужно получить, например SIGUSR1:
        конструирует маску из 0
        конструирует маску из 0, где только SIGUSR1 = 1

        sigwait() - возвращает номер полученного сигнала


Задание:
    sigcopy.c - два аргумента при вызове from, to. Это файлы
      Она запускается, стартует чилда
        parent начинает передовать информацию из from в to
              с помощью сигнала SIGUSR1 = 0
              c помощью сигнала SUGUSR2 = 1
      подводные камни:
        1) рано или поздно сигналы могут склеиться
        2) не гарантирован порядок прихода сигналов
        НАДО ЖДАТЬ
        prog_mask = 0 0 0 0 1 0 0 0 1 0
        хотя первым пришел сигнал  'вторая единичка'
      Решение:
        подтверждать приём бита. Лучше после конца передачи - HUP передать
        Время около минуты на Мб

      При fork() маска сигналов наследуется (те же заблокированные сигналы)
      Хорошая идея - заблокировать все сигналы
